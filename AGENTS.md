# AGENTS.md - Interpreter Project

Clojure interpreter for S-expression bytecode, transpiled to Java via `ly2k`.

## Build Commands

```bash
make build      # Transpile and compile
make test       # Run all tests
make clean      # Clean artifacts
make release    # Release to ly2k packages
```

## Project Structure

```
src/interpreter.clj           # Main source
test/interpreter_test.clj     # Tests
data/sample.clj               # Sample code
data/*.bin                    # Generated bytecode
.github/bin/                  # Build artifacts (gitignored)
```

## Code Style

- **Naming:** `kebab-case` for functions/variables, `kebab-case` for namespaces
- **Private functions:** Use `defn-`
- **Map keys:** Keywords with `snake-case` (`:code-dir`)
- **Type hints:** `^type` sparingly (`^int`, `^String`)
- **Errors:** Use `FIXME` function, no try/catch
- **Return values:** `[value state]` tuples
- **State:** Atoms for mutable state

## Tests

```clojure
(defn- assert_ [fname args expected]
  (let [ng (i/engine_create {:code_dir "data"})
        actual (i/engine_call ng fname args)]
    (if (not= expected actual)
      (FIXME "expected: " expected " actual: " actual))))
```

Run single test: comment out other `assert_` calls in `_main`.

## Notes

- No linting tools - follow existing style
- `ly2k` transpiler at `~/.local/bin/ly2k`
- Do NOT auto-commit - wait for explicit request

## ly2k Transpiler Restrictions

The `ly2k` transpiler supports a subset of Clojure. Key limitations:

- **No `try/catch`** - use `FIXME` for errors
- **No `@` deref syntax** - use `(deref atom)` instead
- **No `:keys` destructuring** - use `(:key map)` accessors
- **No function references in `swap!`** - use lambdas: `(swap! atom (fn [s] (assoc s :key val)))`
- **Field access** - use `(.-field obj)` not `(.field obj)` for fields
- **`reify` requires type hints** - must annotate return type and parameters:
  ```clojure
  (reify android.view.View$OnClickListener
    (^void onClick [this ^android.view.View v]
      ...))
  ```
